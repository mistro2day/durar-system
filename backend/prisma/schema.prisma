generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id           Int             @id @default(autoincrement())
  name         String
  email        String          @unique
  password     String
  role         Role            @default(USER)
  createdAt    DateTime        @default(now())
  activityLogs ActivityLog[]
  resets       PasswordReset[]

  @@index([createdAt], map: "idx_User_createdAt")
}

model Property {
  id        Int          @id @default(autoincrement())
  name      String       @unique
  type      PropertyType
  address   String?
  createdAt DateTime     @default(now())
  units     Unit[]

  @@index([type], map: "idx_Property_type")
}

model Unit {
  id          Int                 @id @default(autoincrement())
  number      String
  type        UnitType
  status      UnitStatus          @default(AVAILABLE)
  propertyId  Int
  createdAt   DateTime            @default(now())
  area        Float?
  baths       Int?                @default(1)
  floor       Int?                @default(0)
  rooms       Int?                @default(1)
  bookings    Booking[]
  contracts   Contract[]
  maintenance MaintenanceTicket[]
  property    Property            @relation(fields: [propertyId], references: [id])

  @@index([number, propertyId], map: "idx_Unit_number_propertyId")
  @@index([propertyId], map: "idx_Unit_propertyId")
  @@index([status], map: "idx_Unit_status")
  @@index([type], map: "idx_Unit_type")
}

model Tenant {
  id                    Int        @id @default(autoincrement())
  name                  String
  phone                 String
  email                 String?
  createdAt             DateTime   @default(now())
  nationalId            String?    @unique
  birthDate             DateTime?
  gender                String?
  nationality           String?
  address               String?
  city                  String?
  country               String?
  employer              String?
  emergencyContactName  String?
  emergencyContactPhone String?
  notes                 String?
  bookings              Booking[]
  contracts             Contract[]
  invoices              Invoice[]
  telegramChatId        String?
  communicationLogs     CommunicationLog[]

  @@index([name], map: "idx_Tenant_name")
}

model Booking {
  id        Int           @id @default(autoincrement())
  tenantId  Int
  unitId    Int
  startDate DateTime
  endDate   DateTime
  total     Float
  status    BookingStatus @default(ACTIVE)
  createdAt DateTime      @default(now())
  tenant    Tenant        @relation(fields: [tenantId], references: [id])
  unit      Unit          @relation(fields: [unitId], references: [id])
  invoices  Invoice[]

  @@index([startDate], map: "idx_Booking_startDate")
  @@index([status], map: "idx_Booking_status")
  @@index([tenantId], map: "idx_Booking_tenantId")
  @@index([unitId], map: "idx_Booking_unitId")
  @@index([unitId, startDate], map: "idx_Booking_unitId_startDate")
}

model Invoice {
  id         Int           @id @default(autoincrement())
  tenantId   Int?
  bookingId  Int?
  contractId Int?
  amount     Float
  dueDate    DateTime
  status     InvoiceStatus @default(PENDING)
  createdAt  DateTime      @default(now())
  booking    Booking?      @relation(fields: [bookingId], references: [id])
  contract   Contract?     @relation(fields: [contractId], references: [id])
  tenant     Tenant?       @relation(fields: [tenantId], references: [id])
  payments   Payment[]

  @@index([bookingId], map: "idx_Invoice_bookingId")
  @@index([contractId], map: "idx_Invoice_contractId")
  @@index([dueDate], map: "idx_Invoice_dueDate")
  @@index([status], map: "idx_Invoice_status")
  @@index([tenantId], map: "idx_Invoice_tenantId")
}

model Payment {
  id        Int           @id @default(autoincrement())
  invoiceId Int
  amount    Float
  method    PaymentMethod
  paidAt    DateTime      @default(now())
  invoice   Invoice       @relation(fields: [invoiceId], references: [id])

  @@index([invoiceId], map: "idx_Payment_invoiceId")
}

model Shop {
  id        Int      @id @default(autoincrement())
  name      String
  location  String?
  phone     String?
  ownerId   Int?
  createdAt DateTime @default(now())

  @@index([ownerId], map: "idx_Shop_ownerId")
}

model MaintenanceTicket {
  id          Int                 @id @default(autoincrement())
  unitId      Int
  description String
  priority    Priority
  status      TicketStatus        @default(NEW)
  createdAt   DateTime            @default(now())
  actions     MaintenanceAction[]
  unit        Unit                @relation(fields: [unitId], references: [id])

  @@index([status], map: "idx_MaintenanceTicket_status")
  @@index([unitId], map: "idx_MaintenanceTicket_unitId")
}

model MaintenanceAction {
  id          Int               @id @default(autoincrement())
  ticketId    Int
  actionTaken String
  performedBy String
  performedAt DateTime          @default(now())
  ticket      MaintenanceTicket @relation(fields: [ticketId], references: [id])

  @@index([ticketId], map: "idx_MaintenanceAction_ticketId")
}

model Contract {
  id                 Int            @id @default(autoincrement())
  tenantId           Int?
  unitId             Int
  startDate          DateTime
  endDate            DateTime
  rentAmount         Float
  status             ContractStatus @default(ACTIVE)
  autoInvoice        Boolean        @default(true)
  createdAt          DateTime       @default(now())
  amount             Float
  rentalType         String
  tenantName         String
  deposit            Float?         @default(0)
  ejarContractNumber String?
  paymentMethod      String?
  paymentFrequency   String?
  servicesIncluded   String?
  notes              String?
  renewalStatus      RenewalStatus  @default(PENDING)
  activityLogs       ActivityLog[]
  tenant             Tenant?        @relation(fields: [tenantId], references: [id])
  unit               Unit           @relation(fields: [unitId], references: [id])
  invoices           Invoice[]

  @@index([endDate], map: "idx_Contract_endDate")
  @@index([startDate], map: "idx_Contract_startDate")
  @@index([status], map: "idx_Contract_status")
  @@index([tenantId], map: "idx_Contract_tenantId")
  @@index([unitId], map: "idx_Contract_unitId")
}

model ActivityLog {
  id          Int       @id @default(autoincrement())
  action      String
  description String?
  contractId  Int?
  userId      Int?
  createdAt   DateTime  @default(now())
  contract    Contract? @relation(fields: [contractId], references: [id])
  user        User?     @relation(fields: [userId], references: [id])

  @@index([contractId], map: "idx_ActivityLog_contractId")
  @@index([createdAt], map: "idx_ActivityLog_createdAt")
  @@index([userId], map: "idx_ActivityLog_userId")
}

model Setting {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  userId    Int
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId], map: "idx_PasswordReset_userId")
}

model CommunicationLog {
  id          Int      @id @default(autoincrement())
  tenantId    Int
  type        String
  content     String
  date        DateTime @default(now())
  performedBy String?
  tenant      Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId], map: "idx_CommunicationLog_tenantId")
}

enum Role {
  ADMIN
  USER
}

enum PropertyType {
  HOTEL
  BUILDING
  COMMERCIAL
}

enum UnitType {
  DAILY
  MONTHLY
  YEARLY
}

enum UnitStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
}

enum BookingStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ContractStatus {
  ACTIVE
  ENDED
  CANCELLED
}

enum InvoiceStatus {
  PENDING
  PAID
  PARTIAL
  OVERDUE
  CANCELLED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  EJAR
}

enum Priority {
  LOW
  MEDIUM
  HIGH
}

enum TicketStatus {
  NEW
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum RenewalStatus {
  PENDING
  RENEWED
  NOT_RENEWING
}
